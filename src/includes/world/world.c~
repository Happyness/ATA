/**
* Contains structs and functions for modifying the game world.
*
* @author Joel Denke      	mail@happyness.se
* @author Marcus Isaksson 	marcus.is@telia.com
* @date   12 april 2012
*/

#ifndef _C_WORLD
#define _C_WORLD

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include "world.h"

int isCollision(struct box a, struct box b)
{
	int x1_1 = a.x, x1_2 = a.x + a.width;
	int x2_1 = b.x, x2_2 = b.x + b.width;
	int y1_1 = a.y, y1_2 = a.y + a.height;
	int y2_1 = b.y, y2_2 = b.y + b.height;
	
	return (x1_2 >= x2_1 && x2_2 >= x1_1) && (y1_2 >= y2_1 && y2_2 >= y1_1);
}

int calculateLengthToMove(struct player * player, enum movement direction)
{
	switch (direction) {
		case left  :
		case right :
			return player->dx - player->dx*FRICTION;
			break;
		case up :
			return player->dy - player->dy*GRAVITY;
			break;
		case down :
			return player->dy + player->dy*GRAVITY;
			break;
	}
}

void movePlayer(struct player* testPlayer, struct object * objects, int noOfObjects, enum movement direction)
{
	int i, collision = 0, objectCollided = -1;
	struct box tmpbox = testPlayer->box;

	switch (direction) {
		case left :
			tmpbox.x -= calculateLengthToMove(testPlayer, direction);
			break;
		case right :
			tmpbox.x += calculateLengthToMove(testPlayer, direction);
			break;
		case up :
			tmpbox.y -= calculateLengthToMove(testPlayer, direction);
			break;
	}
	
	for (i = 0; i < noOfObjects; i++) {
		if (isCollision(tmpbox, objects[i].box)) {
			collision = 1;
			objectCollided = i;
			break;
		}
	}
	
	if (!collision) {
		testPlayer->box = tmpbox;
	} else {
		printf("Player %d collides with object %d", testPlayer->id, objectCollided);
		
		if (objects[objectCollided].movable) {
			if (testPlayer->dx != 0) {
				objects[objectCollided].box.x += testPlayer->dx;
			}
			if (testPlayer->dy != 0) {
				objects[objectCollided].box.y += testPlayer->dy;
			}
		}
	}
}

void gravity(struct player* testPlayer, struct object * objects, int noOfObjects)
{
	int i, collision = 0;
	struct box tmpbox = testPlayer->box;
	enum movement direction = down;
	
	tmpbox.y += calculateLengthToMove(testPlayer, direction);
	
	for (i = 0; i < noOfObjects; i++) {
		if (isCollision(tmpbox, objects[i].box)) {
			collision = 1;
			break;
		}
	}

	if (!collision) {
		testPlayer->box = tmpbox;
	}
}

#endif